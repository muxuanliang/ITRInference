% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/itrInferenceAll.R
\name{ITRFitAll}
\alias{ITRFitAll}
\title{Estimation and inference for individualized treatment rule using pooled-and-split de-correlated score}
\usage{
ITRFitAll(
  data,
  propensity = NULL,
  outcome = NULL,
  loss = "logistic",
  sampleSplitIndex = NULL,
  type.measure = "lossFun",
  outcomeModel = "kernel",
  outcomeFormula = NULL,
  propensityModel = "kernel",
  propensityFormula = NULL,
  intercept = FALSE,
  test = TRUE,
  indexToTest = c(1:8),
  parallel = FALSE,
  screeningMethod = "SIRS",
  outcomeScreeningFamily = "Gaussian",
  standardize = TRUE
)
}
\arguments{
\item{data}{A list - list(predictor = x, treatment = trt, outcome = y)), where x is the covariate matrix, trt is 0 or 1 (1 indicates treatment), y is the outcome.}

\item{propensity}{estimated propensity score p(trt=1|X). This should be used only when the propensity is estimated by a parametric model.}

\item{outcome}{stimated outcome model E(y|trt, X). This should be used only when the outcome is estimated by a parametric model. It should be a list (list(control=..., treatment=...)).}

\item{outcomeModel}{this selects method to estimate the outcome when outcome=NULL. Options include lm, glmnet, kernel, and gam. If lm is used, user also need to input the outcomeFormula like y~x used in lm. By default, kernel regression is selected.}

\item{propensityModel}{Similar to outcomeModel.}

\item{intercept}{includes intercept or not}

\item{test}{whether return p-value and sd estimation.}

\item{indexToTest}{indicates which coefficients to test. By default, c(1:8)}

\item{parallel}{whether use parallel computing; by default, FALSE.}

\item{screeningMethod}{when dimension is high, this selects method to preform variable screening for outcomeModel and propensityModel fitting. Methods in VariableScreening package are available.}

\item{standardize}{whether standardize the input covariant matrix.}
}
\value{
fit is estimated coefficient for ITR on two split datasets. p-values are the p-value for each coefficients included in indexToTest. (betaAN-1.96*sigmaAN/sqrt(sample size), betaAN+1.96*sigmaAN/sqrt(sample size)) provides the 95\% CI for the coefficients.
}
\description{
This function implements the EARL estimation for individualized treatment rule and the inference procedure based on the pooled-and-split de-correlated score (see reference).
}
\examples{
# generate data
n <- 500
p <- 800
x <- array(rnorm(n*p), c(n,p))
beta_pi <- 0.4*c(1,1,1,0,-1,0,-1,rep(0, times=p-7))
trt <- apply(x, 1, function(t){ rbinom(1, 1, prob = exp(t[1]^2+t[2]^2+t[1]*t[2])/(1+exp(t[1]^2+t[2]^2+t[1]*t[2])))})
beta_main <- 0.8*c(-1,-1,1,-1,0,0,rep(0, times=p-6))
main_effect <- exp(x \%*\% beta_main)
beta_inter <- 0.7*c(1,1,-1,-1,rep(0, times=p-4))
interact_effect <- (pnorm(x \%*\% beta_inter)-0.5)*(abs(apply(x[,c(4:8)],1,sum)) + 4 * xi)
e <- rnorm(n)
y <- main_effect + sign(trt - 0.5) * interact_effect + e
# set up training data
dataTrain <- list(predictor = x, treatment = (trt > 0), outcome = y)
# fit our approach
fit_itrAll <- ITRFitAll(data = dataTrain, outcomeModel = 'kernel', propensityModel = 'kernel')
# compare with q-learning and implement standard de-correlated score for q0learning
fit_qlearn <- QLearnFit(data = dataTrain, intercept = TRUE)
score_qlearn <- scoreTestQLearn(fit_qlearn, parallel=FALSE)
}
\references{
To be added
}
\author{
Muxuan Liang <mliang@fredhutch.org>
}
